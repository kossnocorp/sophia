# Rust

layers:
  runtime:
    access:
      - variable.other.rust

    control:
      # *if* a.len() > b.len() {
      - keyword.control.rust
      #
      - keyword.operator.arrow.fat.rust
      # *use* worker::Request;
      - meta.use.rust keyword.other.rust
      # query.first::<Prompts>(None).await*?*;
      - keyword.operator.question.rust

    effect:
      # Box::*new*(...)
      - meta.function.call.rust entity.name.function.rust

    declare:
      # fn *mutable_reference*() {
      - meta.function.definition.rust entity.name.function.rust

    detail:
      # [NOTE] Reset predefined keyword.operator.logical as Rust
      # marks a lot of stuff like this *(|*error*|* ...
      - keyword.operator.logical.rust
      #  println!*(*"{error:?}"*)*
      - punctuation.brackets.round.rust
      # match *{* ... *}*
      - punctuation.brackets.curly.rust
      # println!()*;*
      - punctuation.semi.rust
      # fn main() *->* ...
      - keyword.operator.arrow.skinny.rust
      # std*::*sync*::*mpsc*::*channel();
      - keyword.operator.namespace.rust

  memory:
    effect:
      # let r1 = *&*x as *const i32
      - keyword.operator.borrow.and.rust
      # ***y += 5;
      - keyword.operator.dereference.rust
      # struct RefStruct<*'*a> { ...
      - punctuation.definition.lifetime.rust
      # *mut* i32
      - storage.modifier.mut.rust

  types:
    detail:
      # Result*<*Response, Error*>*
      - punctuation.brackets.angle.rust

  macro:
    control:
      # *macro_rules!* println { ... }
      - entity.name.function.macro.rules.rust
      #
      - keyword.operator.macro.dollar.rust

    effect:
      # *println!*("Hello, world!");
      - meta.macro.rust

    declare:
      # macro_rules! *println* { ... }
      - entity.name.function.macro.rust
